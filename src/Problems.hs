module Problems where

import Fibonacci
import Data.List

problem1 :: Integer
{- If we list all the natural numbers below 10 that are multiples of 3 or 5, 
    we get 3, 5, 6 and 9. The sum of these multiples is 23.
   Find the sum of all the multiples of 3 or 5 below 1000. -}
problem1 = sum [ x | x <- [1..999], mod x 3 == 0 || mod x 5 == 0]


problem2 :: Integer
{- Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
Find the sum of all the even-valued terms in the sequence which do not exceed four million. -}
problem2 = sum . takeWhile (<4000000) . filter even  $ fibonacci

problem4 :: Int
{- A palindromic number reads the same both ways. The largest palindrome 
   made from the product of two 2-digit numbers is 9009 = 91 
   Find the largest palindrome made from the product of two 3-digit numbers. -}
problem4 =  maximum(filter palindrome $ Data.List.sort(multidown 999 100))

tenEx :: Int -> Int -- Gives the 10 base exponent for the Int. example exponent 545 = 3
tenEx b = truncate (logBase 10.0 (fromIntegral b))

intLength :: Int -> Int -- Gives the length of an integer
intLength x = truncate (logBase 10.0 (fromIntegral x)) + 1

subPalindrome :: Int -> Int -> Bool
{- x is the number and y is the position from both left and right that we are comparing -}
subPalindrome x y = mod (div x (10 ^ (tenEx x - y + 1))) 10 == truncate( fromIntegral(mod x (10^y)) / fromIntegral(10^(y - 1)) )

palindrome :: Int -> Bool -- Returns a boolean stating if an integer is a boolean
palindrome p = length(takeWhile(subPalindrome p)$[1..(div (intLength p) 2)]) == div (intLength p) 2

multidown :: Int -> Int ->[Int] -- returns a list that contains all products of two list made up of the number between a and b
multidown x y
  | x <= 0  = error "must be >=0 "
  | x <= y  = error "x must be larger than y"
  | x > 0  = [a * z | z <- [x,x-1..y],a <- [x,x-1..y]]


problem5 :: Integer
{- 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without 
   any remainder.
   What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20? -}
problem5 = euler5 20  

euler5 :: Integer -> Integer
euler5 z = head [x|x<- map(* (z * (z-1)))[1..product[1..z]], sum( map (mod x) [(div z 2) + 1..(z-2)]) == 0]

  